IMPLEMENTATION MODULE LOT_GPda;

FROM Objects IMPORT
  TRect, DisposeStr, NewStr, PString;
FROM Drivers IMPORT
  TEvent, EventType;
FROM IntInputLines IMPORT
  PIntInputLine;
FROM RealInputLines IMPORT
  PRealInputLine;
FROM InputLines IMPORT
  PInputLine, TInputLine;
FROM StaticTexts IMPORT
  PStaticText;
FROM CheckBoxes IMPORT
  PCheckBoxes;
FROM Clusters IMPORT
  NewSItem;
FROM Dialogs IMPORT
  PDialog, TDialog;
FROM Views IMPORT
  TViewOption, TViewOptions, ofCentered, EnableCommand, DisableCommand;
FROM Labels IMPORT
  PLabel;
FROM Storage IMPORT
  ALLOCATE, DEALLOCATE;
FROM Hist IMPORT
  DefineHistorySubView, SetNotification, VHF_HIST_ID, DefineFreqListSubView;
FROM Str IMPORT
  Copy, StrToInt, Compare, StrToCard, StrToReal, Item, CHARSET, Delete;
FROM StringCollections IMPORT
  PStringCollection;
FROM ListBoxes IMPORT
  PListBox;
FROM Buttons IMPORT
  PButton, ButtonFlag, ButtonFlags;
FROM ScrollBars IMPORT
  PScrollBar;
FROM Ini IMPORT
  WritePrivateProfileString, GetPrivateProfileString, DeleteSection;
FROM stdio IMPORT
  sprintf, sscanf;
FROM HistList IMPORT
  HistoryAdd, HistoryStr, HistoryCount, HistoryDelete;
FROM Warn IMPORT
  LockCnt;
FROM DB_utl IMPORT
  UtnijSpacje, CompareBezSpacji;
IMPORT
  Str, Potw;
FROM DB_Common IMPORT
  BlokGPS,SetBlockGPS,Blok;


TYPE
  PLOTGSD = POINTER TO LOTGPS;


VAR
  p : PLOTGSD;
  Desktop : PGroup;

CONST
  LOT_LIST = "LotnList.ini";



CLASS LOTGPS( TDialog );
  AktualneLotnisko: ARRAY[0..127] OF CHAR;
   GPSLOC            : BlokGPS;
   GPSGS            : BlokGPS;
   PROCEDURE Init;
   PROCEDURE Zapisz;
   PROCEDURE Odczytaj;
   PROCEDURE Ok;
   PROCEDURE Cancel;
   VIRTUAL PROCEDURE Done;
   VIRTUAL PROCEDURE HandleEvent( VAR E : TEvent );
END LOTGPS;


CLASS IMPLEMENTATION LOTGPS;

  PROCEDURE Init;
  VAR
    R : TRect;
    n : PInputLine;
    l : PLabel;
    st : PStaticText;
    Button : PButton;

    PROCEDURE SetReal(     LabelText : ARRAY OF CHAR;
                       VAR p         : PRealInputLine;
                           max       : LONGREAL;
                           y         : CARDINAL      );
    BEGIN
      R.Assign( 15, y, 32, y+1 );
      NEW( p );
      p^.Init( R, 15, 0.0, max );
      p^.SetFormat( "%.2lf" );
      Insert( p );

      R.Assign( 2, y, 15, y+1 );
      NEW( l );
      l^.Init( R, LabelText, p );
      Insert( l );

    END SetReal;

    PROCEDURE SetInt(     LabelText : ARRAY OF CHAR;
                      VAR p         : PIntInputLine;
                          y         : CARDINAL      );
    BEGIN
      R.Assign( 15, y, 32, y+1 );
      NEW( p );
      p^.Init( R, 15, -180, 359 );
      p^.SetFormat( "%03d" );
      Insert( p );

      R.Assign( 2, y, 15, y+1 );
      NEW( l );
      l^.Init( R, LabelText, p );
      Insert( l );

    END SetInt;


  BEGIN
    INC( LockCnt );
    DisableCommand( cmLOTGPSdatabase );
    R.Assign( 0, 0, 38, 15 );
    

    TDialog.Init( R, "Baza danych GPS" );
    Options := Options + ofCentered ;


    R.Assign( 2, 1, 15, 2 );
      NEW( st );
      st^.Init( R, "GPS LOC" );
      Insert( st );
      SetBlockGPS( SELF, GPSLOC , 2, 2);



      R.Assign( 2, 6, 15, 7 );
      NEW( st );
      st^.Init( R, "GPS GS" );
      Insert( st );
      SetBlockGPS( SELF, GPSGS , 2, 7);

      R.Assign( 2, 12, 8, 14 );
      NEW( Button );
      Button^.Init( R, "~O~k", cmOk, ButtonFlags{ bfDefault } );
      Insert( Button );
      R.Assign( 8, 12, 18, 14 );
      NEW( Button );
      Button^.Init( R, "~C~ancel", cmCancel, ButtonFlags{ bfNormal } );
      Insert( Button);
    p := ADR( SELF );
    Odczytaj;

  END Init;

  VIRTUAL PROCEDURE HandleEvent( VAR E : TEvent );
  BEGIN
    TDialog.HandleEvent( E );
    IF evCommand IN E.What THEN
      CASE E.Command OF
      |cmOk :
                Ok;
      |cmCancel :
          Cancel;

      ELSE
        RETURN;
      END;
    END;
  END HandleEvent;

  PROCEDURE Cancel;

  BEGIN
  
   DEC( LockCnt );
   EnableCommand( cmLOTGPSdatabase ); 
   
    TDialog.Done;

  END Cancel;


  PROCEDURE Ok;
  VAR
  BEGIN
  Done;
 
  END Ok;


  PROCEDURE Zapisz;
  VAR
    s : ARRAY[0..127] OF CHAR;

    PROCEDURE TextI( il : PIntInputLine; Entry : ARRAY OF CHAR );
    BEGIN
      il^.TInputLine.GetData( s );
      WritePrivateProfileString( AktualneLotnisko,
                                 Entry,
                                 s,
                                 LOT_LIST  );
     END TextI;

    PROCEDURE TextR( il : PRealInputLine; Entry : ARRAY OF CHAR );
    BEGIN
      il^.TInputLine.GetData( s );
      WritePrivateProfileString( AktualneLotnisko,
                                 Entry,
                                 s,
                                 LOT_LIST  );
     END TextR;

  VAR
    i, j : CARDINAL;
    fr   : LONGREAL;
    str  : ARRAY[0..20] OF CHAR;
  BEGIN
    WHILE AktualneLotnisko[0] = ' ' DO
      Str.Delete( AktualneLotnisko, 0, 1 );
    END;
    IF AktualneLotnisko[0] = 0C THEN
      RETURN;
    END;
    TextR( GPSGS.Odleglosc,     "GPSGS.Odleglosc" );
    TextR( GPSGS.Wysokosc,      "GPSGS.Wysokosc" );
    TextR( GPSGS.Kat,           "GPSGS.Kat" );
    TextR( GPSLOC.Odleglosc,   "GPSLOC.Odleglosc");
    TextR( GPSLOC.Wysokosc,    "GPSLOC.Wysokosc" );
    TextR( GPSLOC.Kat,         "GPSLOC.Kat" );

  END Zapisz;

  PROCEDURE Odczytaj;
  VAR
    s : ARRAY[0..127] OF CHAR;
    CalkowitaIlosc, i, j : INTEGER;
    ok : BOOLEAN;
    sp : PString;

    PROCEDURE TextI( il : PIntInputLine; Entry : ARRAY OF CHAR );
    VAR
      i : INTEGER;
    BEGIN
      GetPrivateProfileString( AktualneLotnisko,
                               Entry,
                               "00",
                               s,
                               LOT_LIST  );
      Item( s, s, CHARSET{' '}, 0 );
      i := VAL( INTEGER, StrToInt( s, 10, ok ));
      IF NOT ok THEN
        i := 0;
      END;
      il^.SetData( i );
    END TextI;

    PROCEDURE TextR( il : PRealInputLine; Entry : ARRAY OF CHAR );
    VAR
      r : LONGREAL;
    BEGIN
      GetPrivateProfileString( AktualneLotnisko,
                               Entry,
                               "00",
                               s,
                               LOT_LIST  );
      Item( s, s, CHARSET{' '}, 0 );
      r := StrToReal( s, ok );
      IF NOT ok THEN
        r := 0.0;
      END;
      il^.SetData( r );
    END TextR;

  VAR
    fr : LONGREAL;
    str  : ARRAY[0..20] OF CHAR;
  BEGIN
    IF AktualneLotnisko[0] = 0C THEN
      RETURN;
    END;
    TextR( GPSGS.Odleglosc,     "GPSGS.Odleglosc" );
    TextR( GPSGS.Wysokosc,      "GPSGS.Wysokosc" );
    TextR( GPSGS.Kat,           "GPSGS.Kat" );
    TextR( GPSLOC.Odleglosc,   "GPSLOC.Odleglosc");
    TextR( GPSLOC.Wysokosc,    "GPSLOC.Wysokosc" );
    TextR( GPSLOC.Kat,         "GPSLOC.Kat" );
  END Odczytaj;


  VIRTUAL PROCEDURE Done;
  VAR
    s : ARRAY[0..1] OF CHAR;
    i : INTEGER;
  BEGIN
    DEC( LockCnt );
    Zapisz;
    EnableCommand( cmLOTGPSdatabase );
    TDialog.Done;
  END Done;

BEGIN
  AktualneLotnisko[0] := 0C;
END LOTGPS;


PROCEDURE LOTGPSdatabase( p : PGroup; 
                          AktLotnisko:ARRAY OF CHAR );


VAR
  d : PLOTGSD;
  VAR
    Dlg     : PDialog;
    R       : TRect;
    st : PStaticText;
 
BEGIN

  NEW( d );
  Desktop := p;
  WITH d^ DO 
    Copy( AktualneLotnisko, AktLotnisko );
  Odczytaj;

    R.Assign( 0, 0, 38, 15 );
    NEW (Dlg);
     WITH Dlg^ DO
     Init( R, "Baza danych GPS" );

    Options := Options + ofCentered ;

      R.Assign( 2, 1, 15, 2 );
      NEW( st );
      st^.Init( R, "GPS LOC" );
      Insert( st );
 (*     SetBlockGPS( SELF, GPSLOC , 2, 2);*)

    END; 
    IF Desktop^.ExecView( Dlg ) # cmCancel THEN

    END;
    Dlg^.Done;
    DISPOSE( Dlg );

 (*   Init;
    p^.Insert( d );*)
  END;
END LOTGPSdatabase;

BEGIN
  p := NIL;
END LOT_GPda.
